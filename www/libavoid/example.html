<html>
<head><title>libavoid Documentation</title>
<style>
pre { border: dotted 1px #900; padding: 5px; background-color: #ffe; }
body { padding-top: 10px; padding-left: 60px; padding-right: 60px; }
</style
</head>
<body>
<h1>libavoid Documentation</h1>

<p>Last updated for Adaptagrams repository $Revision$.</p>

<p><i>Note: This interface may change over the coming months, prior to the first official release, as orthogonal routing and other features are added to libavoid.</i></p>

<p>libavoid is a C++ library.  Its code is all within the <code>Avoid::</code> namespace.</p>

<p>First, you must create an instance of the router. 
<pre>Avoid::Router *router = new Avoid::Router(Avoid::PolyLineRouting);</pre></p>

<p>To add a shape (obstacle) to the router, you first create a <code>ShapeRef</code> by giving the bounding box of the obstacle.
<pre>// Create the ShapeRef:
Avoid::Rectangle rectangle(Avoid::Point(20, 35), Avoid::Point(40, 12));
Avoid::ShapeRef *shapeRef = new Avoid::ShapeRef(router, rectangle);</pre>
or
<pre>
Avoid::Polygon shapePoly(3);
shapePoly.ps[0] = Avoid::Point(1, 1);
shapePoly.ps[1] = Avoid::Point(2.5, 1.5);
shapePoly.ps[2] = Avoid::Point(1.5, 2.5);
Avoid::ShapeRef *shapeRef = new Avoid::ShapeRef(router, shapePoly);</pre></p>

<p>The relevant prototypes (all in the Avoid namespace) are as follows.  If a shape ID is specified, it should be non-zero and unique among all shapes and connectors.
<pre>Rectangle(const Point& topLeft, const Point bottomRight);
Rectangle(const Point& centre, const double width, const double height);
ShapeRef(Router *router, const Polygon& polygon, unsigned int id = 0);</pre>

<p>To actually add the shape to the router (and cause rerouting of connectors it intersects) you do the following:
<pre>router-&gt;addShape(shapeRef);</pre></p>

<p>Conversely, to delete a shape from the router (and reroute connectors that then have a better path) you do the following.  
<pre>router-&gt;removeShape(shapeRef);</pre></p>

<p>To move or resize a shape already in the router, you do the following:
<pre>router-&gt;moveShape(shapeRef, newPolygon);</pre>
or
<pre>double xmove = 20, ymove = 15;
router-&gt;moveShape(shapeRef, xmove, ymove);</pre></p>

<p>In its default mode the router will queue multiple shape movements and perform the changes to the visibility graph in an optimised order.  Thus you make several calls to <code>router-&gt;moveShape()</code> for different shapes and then tell the router to process the moves.  This tend to be useful in interactive applications where the user may move multiple shapes at once.
<pre>router-&gt;moveShape(shapeRef1, newPolygon1);
router-&gt;moveShape(shapeRef2, newPolygon2);
router-&gt;processMoves();
</pre></p>

<p>To add a new connector to the router, you do the following:
<pre>
Avoid::ConnEnd srcPt(Avoid::Point(1.2, 0.5));
Avoid::ConnEnd dstPt(Avoid::Point(3, 4));
Avoid::ConnRef *connRef = new Avoid::ConnRef(router, srcPt, dstPt);</pre></p>

<p>To remove a connector from the router:
<pre>delete connRef;</pre></p>

<p>You can set a function to be called when the connector needs to be redrawn.  When called, this function will be passed the pointer given as a second argument to <code>setCallback</code>:
<pre>void connCallback(void *ptr)
{
    Avoid::ConnRef *connRef = (Avoid::ConnRef *) ptr; 

    printf("Connector %u needs rerouting!\n", connRef-&gt;id());
}

connRef-&gt;setCallback(connCallback, connRef);</pre></p>

<p>The callback will be triggered by movement, addition and deletion of shapes.  Adjusting the connector endpoints will not trigger it since if you're altering the endpoints you probably want to trigger the rerouting yourself.  You can check if a connector needs to be rerouted (say because a better path is available by a deleted shape):
<pre>if (connRef-&gt;needsReroute()) ...</pre></p>

<p>If you want to trigger the callback for a connector after moving its endpoints (or when it is first created you can do this via:
<pre>connRef->performReroutingCallback();</pre></p>

<p>To generate a new path for a connector you do the following:
<pre>connRef-&gt;generatePath();</pre>

<p>You can then get the new path as follows:

<pre>const Avoid::PolyLine route = connRef-&gt;route();
for (size_t i = 0; i &lt; route.size(); ++i) 
{
    Avoid::Point point = route.at(i);
    // Prints the points of a connector, from source to destination.
    printf("%f, %f\n", point.x, point.y);
}</pre></p>       

<p>Obviously the alternative to using the callback mechanism is to iterate through all connectors and check their needsReroute() value after having called processMoves().</p>

<p>You can update the endpoints of a connector with:
<pre>Avoid::ConnEnd newSrcPt(Avoid::Point(6, 3));
Avoid::ConnEnd newDstPt(Avoid::Point(12, 67));
connRef-&gt;setEndpoints(newSrcPt, newDstPt);</pre>
or
<pre>Avoid::ConnEnd newSrcPt(Avoid::Point(6, 3));
connRef-&gt;setSourceEndpoint(newSrcPt);

Avoid::ConnEnd newDstPt(Avoid::Point(6, 3));
connRef-&gt;setDestEndpoint(newDstPt);</pre>
</p>

<p>(Then ConnEnd type exists to allow connector ports later on!)</p>

<p>See also a short example: example.cpp in the libavoid/tests directory</p>

</body>
