<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Avoid::ConnRef Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<style>
pre { 
    border: dotted 1px #900; 
    padding: 5px; 
    background-color: #ffe;
}
a.anchor:hover {
    text-decoration: none;
}
</style>
</head>
<body>
<!-- Generated by Doxygen 1.8.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_avoid.html">Avoid</a></li><li class="navelem"><a class="el" href="class_avoid_1_1_conn_ref.html">ConnRef</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_avoid_1_1_conn_ref-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Avoid::ConnRef Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="class_avoid_1_1_conn_ref.html" title="The ConnRef class represents a connector object.">ConnRef</a> class represents a connector object.  
 <a href="class_avoid_1_1_conn_ref.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="connector_8h_source.html">connector.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2e08b9bb04ccf383700487932f13c980"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#a2e08b9bb04ccf383700487932f13c980">ConnRef</a> (<a class="el" href="class_avoid_1_1_router.html">Router</a> *<a class="el" href="class_avoid_1_1_conn_ref.html#afdf38806b8b56e43300646a7db58443a">router</a>, const unsigned int <a class="el" href="class_avoid_1_1_conn_ref.html#a2bc4552e6d1b80c9ec38a971efb0d378">id</a>=0)</td></tr>
<tr class="memdesc:a2e08b9bb04ccf383700487932f13c980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a connector with no endpoints specified.  <a href="#a2e08b9bb04ccf383700487932f13c980"></a><br/></td></tr>
<tr class="separator:a2e08b9bb04ccf383700487932f13c980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa469b1767d12e1fa4971004225a0abcd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#aa469b1767d12e1fa4971004225a0abcd">ConnRef</a> (<a class="el" href="class_avoid_1_1_router.html">Router</a> *<a class="el" href="class_avoid_1_1_conn_ref.html#afdf38806b8b56e43300646a7db58443a">router</a>, const <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a> &amp;src, const <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a> &amp;dst, const unsigned int <a class="el" href="class_avoid_1_1_conn_ref.html#a2bc4552e6d1b80c9ec38a971efb0d378">id</a>=0)</td></tr>
<tr class="memdesc:aa469b1767d12e1fa4971004225a0abcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a connector with endpoints specified.  <a href="#aa469b1767d12e1fa4971004225a0abcd"></a><br/></td></tr>
<tr class="separator:aa469b1767d12e1fa4971004225a0abcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12f46fe3ea2f98e687f5a942d0cd51e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#ac12f46fe3ea2f98e687f5a942d0cd51e">~ConnRef</a> ()</td></tr>
<tr class="memdesc:ac12f46fe3ea2f98e687f5a942d0cd51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connector reference destuctor.  <a href="#ac12f46fe3ea2f98e687f5a942d0cd51e"></a><br/></td></tr>
<tr class="separator:ac12f46fe3ea2f98e687f5a942d0cd51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66e8c90dc191951fc0f64acc4c06d7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#ae66e8c90dc191951fc0f64acc4c06d7c">setEndpoints</a> (const <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a> &amp;srcPoint, const <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a> &amp;dstPoint)</td></tr>
<tr class="memdesc:ae66e8c90dc191951fc0f64acc4c06d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets both a new source and destination endpoint for this connector.  <a href="#ae66e8c90dc191951fc0f64acc4c06d7c"></a><br/></td></tr>
<tr class="separator:ae66e8c90dc191951fc0f64acc4c06d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ab41f9847a610ba17a326cd05cb266"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#a45ab41f9847a610ba17a326cd05cb266">setSourceEndpoint</a> (const <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a> &amp;srcPoint)</td></tr>
<tr class="memdesc:a45ab41f9847a610ba17a326cd05cb266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets just a new source endpoint for this connector.  <a href="#a45ab41f9847a610ba17a326cd05cb266"></a><br/></td></tr>
<tr class="separator:a45ab41f9847a610ba17a326cd05cb266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b216c9aa42811f1f2786adbda84f02e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#a7b216c9aa42811f1f2786adbda84f02e">setDestEndpoint</a> (const <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a> &amp;dstPoint)</td></tr>
<tr class="memdesc:a7b216c9aa42811f1f2786adbda84f02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets just a new destination endpoint for this connector.  <a href="#a7b216c9aa42811f1f2786adbda84f02e"></a><br/></td></tr>
<tr class="separator:a7b216c9aa42811f1f2786adbda84f02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc4552e6d1b80c9ec38a971efb0d378"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#a2bc4552e6d1b80c9ec38a971efb0d378">id</a> (void) const </td></tr>
<tr class="memdesc:a2bc4552e6d1b80c9ec38a971efb0d378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ID of this connector.  <a href="#a2bc4552e6d1b80c9ec38a971efb0d378"></a><br/></td></tr>
<tr class="separator:a2bc4552e6d1b80c9ec38a971efb0d378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf38806b8b56e43300646a7db58443a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_avoid_1_1_router.html">Router</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#afdf38806b8b56e43300646a7db58443a">router</a> (void) const </td></tr>
<tr class="memdesc:afdf38806b8b56e43300646a7db58443a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the router scene this connector is in.  <a href="#afdf38806b8b56e43300646a7db58443a"></a><br/></td></tr>
<tr class="separator:afdf38806b8b56e43300646a7db58443a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1220a1f50485733bdc291736023f5f39"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#a1220a1f50485733bdc291736023f5f39">needsRepaint</a> (void) const </td></tr>
<tr class="memdesc:a1220a1f50485733bdc291736023f5f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an indication of whether this connector has a new route and thus needs to be repainted.  <a href="#a1220a1f50485733bdc291736023f5f39"></a><br/></td></tr>
<tr class="separator:a1220a1f50485733bdc291736023f5f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f24407bc92dd5a28e7c9d60d28d38b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_avoid.html#afaa0d7df841c3bace9f3342dab6bc07c">PolyLine</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#a98f24407bc92dd5a28e7c9d60d28d38b">route</a> (void) const </td></tr>
<tr class="memdesc:a98f24407bc92dd5a28e7c9d60d28d38b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the current route for the connector.  <a href="#a98f24407bc92dd5a28e7c9d60d28d38b"></a><br/></td></tr>
<tr class="separator:a98f24407bc92dd5a28e7c9d60d28d38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7462cd69bd1d2c4dd318119558b4a94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_avoid.html#afaa0d7df841c3bace9f3342dab6bc07c">PolyLine</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#ab7462cd69bd1d2c4dd318119558b4a94">displayRoute</a> (void)</td></tr>
<tr class="memdesc:ab7462cd69bd1d2c4dd318119558b4a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the current display version of the route for the connector.  <a href="#ab7462cd69bd1d2c4dd318119558b4a94"></a><br/></td></tr>
<tr class="separator:ab7462cd69bd1d2c4dd318119558b4a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1a26643759adbb84f350285ce42d64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#a9d1a26643759adbb84f350285ce42d64">setCallback</a> (void(*cb)(void *), void *ptr)</td></tr>
<tr class="memdesc:a9d1a26643759adbb84f350285ce42d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a callback function that will called to indicate that the connector needs rerouting.  <a href="#a9d1a26643759adbb84f350285ce42d64"></a><br/></td></tr>
<tr class="separator:a9d1a26643759adbb84f350285ce42d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b310492a0cf7831694815c79776e7ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_avoid.html#a2dc870f7d17f81f6833e3bb8e77762c2">ConnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#a1b310492a0cf7831694815c79776e7ed">routingType</a> (void) const </td></tr>
<tr class="memdesc:a1b310492a0cf7831694815c79776e7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of routing performed for this connector.  <a href="#a1b310492a0cf7831694815c79776e7ed"></a><br/></td></tr>
<tr class="separator:a1b310492a0cf7831694815c79776e7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb2eb95a4bfa94fa04081a0bb015583"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#acfb2eb95a4bfa94fa04081a0bb015583">setRoutingType</a> (<a class="el" href="namespace_avoid.html#a2dc870f7d17f81f6833e3bb8e77762c2">ConnType</a> type)</td></tr>
<tr class="memdesc:acfb2eb95a4bfa94fa04081a0bb015583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the type of routing to be performed for this connector.  <a href="#acfb2eb95a4bfa94fa04081a0bb015583"></a><br/></td></tr>
<tr class="separator:acfb2eb95a4bfa94fa04081a0bb015583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372f58a93c0296814de8d4a3075ad5e4"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="class_avoid_1_1_junction_ref.html">JunctionRef</a> <br class="typebreak"/>
*, <a class="el" href="class_avoid_1_1_conn_ref.html">ConnRef</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#a372f58a93c0296814de8d4a3075ad5e4">splitAtSegment</a> (const size_t segmentN)</td></tr>
<tr class="memdesc:a372f58a93c0296814de8d4a3075ad5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a connector in the centre of the segmentNth segment and creates a junction point there as well as a second connector.  <a href="#a372f58a93c0296814de8d4a3075ad5e4"></a><br/></td></tr>
<tr class="separator:a372f58a93c0296814de8d4a3075ad5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc22448cc52a1b060f62bcc00d1bb93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#a7fc22448cc52a1b060f62bcc00d1bb93">setRoutingCheckpoints</a> (const std::vector&lt; <a class="el" href="class_avoid_1_1_checkpoint.html">Checkpoint</a> &gt; &amp;checkpoints)</td></tr>
<tr class="memdesc:a7fc22448cc52a1b060f62bcc00d1bb93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the user to specify a set of checkpoints that this connector will route via.  <a href="#a7fc22448cc52a1b060f62bcc00d1bb93"></a><br/></td></tr>
<tr class="separator:a7fc22448cc52a1b060f62bcc00d1bb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a43ab308285370b304ca2651480ff7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_avoid_1_1_checkpoint.html">Checkpoint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#a19a43ab308285370b304ca2651480ff7">routingCheckpoints</a> (void) const </td></tr>
<tr class="memdesc:a19a43ab308285370b304ca2651480ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current set of routing checkpoints for this connector.  <a href="#a19a43ab308285370b304ca2651480ff7"></a><br/></td></tr>
<tr class="separator:a19a43ab308285370b304ca2651480ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13c20a3c4e4a1bccc217ee77c85375f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a>, <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#aa13c20a3c4e4a1bccc217ee77c85375f">endpointConnEnds</a> (void) const </td></tr>
<tr class="memdesc:aa13c20a3c4e4a1bccc217ee77c85375f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns ConnEnds specifying what this connector is attached to.  <a href="#aa13c20a3c4e4a1bccc217ee77c85375f"></a><br/></td></tr>
<tr class="separator:aa13c20a3c4e4a1bccc217ee77c85375f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="class_avoid_1_1_conn_ref.html" title="The ConnRef class represents a connector object.">ConnRef</a> class represents a connector object. </p>
<p>Connectors are a (possible multi-segment) line between two points. They are routed intelligently so as not to overlap any of the shape objects in the <a class="el" href="class_avoid_1_1_router.html" title="The Router class represents a libavoid router instance.">Router</a> scene.</p>
<p>Routing penalties can be applied, resulting in more aesthetically pleasing connector paths with fewer segments or less severe bend-points.</p>
<p>You can set a function to be called when the connector has been rerouted and needs to be redrawn. Alternatively, you can query the connector's <a class="el" href="class_avoid_1_1_conn_ref.html#a1220a1f50485733bdc291736023f5f39" title="Returns an indication of whether this connector has a new route and thus needs to be repainted...">needsRepaint()</a> function to determine this manually.</p>
<p>Usually, it is expected that you would create a <a class="el" href="class_avoid_1_1_conn_ref.html" title="The ConnRef class represents a connector object.">ConnRef</a> for each connector in your diagram and keep that reference in your own connector class. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2e08b9bb04ccf383700487932f13c980"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Avoid::ConnRef::ConnRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_avoid_1_1_router.html">Router</a> *&#160;</td>
          <td class="paramname"><em>router</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>id</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a connector with no endpoints specified. </p>
<p>The constructor requires a valid <a class="el" href="class_avoid_1_1_router.html" title="The Router class represents a libavoid router instance.">Router</a> instance. This router will take ownership of the connector. Hence, you should not call the destructor yourself, but should instead call <a class="el" href="class_avoid_1_1_router.html#a316f15b3e974c273bb55cfb19b751394" title="Remove a connector from the router scene.">Router::deleteConnector()</a> and the router instance will remove and then free the connector's memory.</p>
<p>If an ID is not specified, then one will be assigned to the shape. If assigning an ID yourself, note that it should be a unique positive integer. Also, IDs are given to all objects in a scene, so the same ID cannot be given to a shape and a connector for example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">router</td><td>The router scene to place the connector into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>A unique positive integer ID for the connector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa469b1767d12e1fa4971004225a0abcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Avoid::ConnRef::ConnRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_avoid_1_1_router.html">Router</a> *&#160;</td>
          <td class="paramname"><em>router</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>id</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a connector with endpoints specified. </p>
<p>The constructor requires a valid <a class="el" href="class_avoid_1_1_router.html" title="The Router class represents a libavoid router instance.">Router</a> instance. This router will take ownership of the connector. Hence, you should not call the destructor yourself, but should instead call <a class="el" href="class_avoid_1_1_router.html#a316f15b3e974c273bb55cfb19b751394" title="Remove a connector from the router scene.">Router::deleteConnector()</a> and the router instance will remove and then free the connector's memory.</p>
<p>If an ID is not specified, then one will be assigned to the shape. If assigning an ID yourself, note that it should be a unique positive integer. Also, IDs are given to all objects in a scene, so the same ID cannot be given to a shape and a connector for example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">router</td><td>The router scene to place the connector into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>A unique positive integer ID for the connector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The source endpoint of the connector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>The destination endpoint of the connector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac12f46fe3ea2f98e687f5a942d0cd51e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Avoid::ConnRef::~ConnRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connector reference destuctor. </p>
<p>Do not call this yourself, instead call <a class="el" href="class_avoid_1_1_router.html#a316f15b3e974c273bb55cfb19b751394" title="Remove a connector from the router scene.">Router::deleteConnector()</a>. Ownership of this object belongs to the router scene. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab7462cd69bd1d2c4dd318119558b4a94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_avoid_1_1_polygon.html">Polygon</a> &amp; Avoid::ConnRef::displayRoute </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the current display version of the route for the connector. </p>
<p>The display version of a route has been simplified to collapse all collinear line segments into single segments. It may also have post-processing applied to the route, such as curved corners or nudging.</p>
<dl class="section return"><dt>Returns</dt><dd>The PolyLine display route for the connector. </dd></dl>

</div>
</div>
<a class="anchor" id="aa13c20a3c4e4a1bccc217ee77c85375f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a>, <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a> &gt; Avoid::ConnRef::endpointConnEnds </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns ConnEnds specifying what this connector is attached to. </p>
<p>This may be useful during hyperedge rerouting. You can check the type and properties of the <a class="el" href="class_avoid_1_1_conn_end.html" title="The ConnEnd class represents different possible endpoints for connectors.">ConnEnd</a> objects to find out what this connector is attached to. The <a class="el" href="class_avoid_1_1_conn_end.html#a3b78a32882517eb723068636a289ff55" title="Returns the kind of connection this ConnEnd represents.">ConnEnd::type()</a> will be ConnEndEmpty if the connector has not had its endpoints initialised.</p>
<dl class="section note"><dt>Note</dt><dd>If the router is using transactions, you might get unexpected results if you call this after changing objects but before calling <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">Router::processTransaction()</a>. In this case changes to ConnEnds for the connector may be queued and not yet applied, so you will get old (or empty) values.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of <a class="el" href="class_avoid_1_1_conn_end.html" title="The ConnEnd class represents different possible endpoints for connectors.">ConnEnd</a> objects specifying what the connector is attached to. </dd></dl>

</div>
</div>
<a class="anchor" id="a2bc4552e6d1b80c9ec38a971efb0d378"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Avoid::ConnRef::id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ID of this connector. </p>
<dl class="section return"><dt>Returns</dt><dd>The ID of the connector. </dd></dl>

</div>
</div>
<a class="anchor" id="a1220a1f50485733bdc291736023f5f39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Avoid::ConnRef::needsRepaint </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an indication of whether this connector has a new route and thus needs to be repainted. </p>
<p>If the connector has been rerouted and need repainting, the <a class="el" href="class_avoid_1_1_conn_ref.html#ab7462cd69bd1d2c4dd318119558b4a94" title="Returns a reference to the current display version of the route for the connector.">displayRoute()</a> method can be called to get a reference to the new route.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the connector requires repainting, or false if it does not. </dd></dl>

</div>
</div>
<a class="anchor" id="a98f24407bc92dd5a28e7c9d60d28d38b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_avoid.html#afaa0d7df841c3bace9f3342dab6bc07c">PolyLine</a> &amp; Avoid::ConnRef::route </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the current route for the connector. </p>
<p>This is a "raw" version of the route, where each line segment in the route may be made up of multiple collinear line segments. It will also not have post-processing (like curved corners) applied to it. The simplified route for display can be obtained by calling <a class="el" href="class_avoid_1_1_conn_ref.html#ab7462cd69bd1d2c4dd318119558b4a94" title="Returns a reference to the current display version of the route for the connector.">displayRoute()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The PolyLine route for the connector. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>You can obtain a modified version of this poly-line route with curved corners added by calling <a class="el" href="class_avoid_1_1_polygon.html#a37c1371329c57705b74e8b557ca102ff" title="Returns a curved approximation of this multi-segment PolyLine, with the corners replaced by smooth Be...">PolyLine::curvedPolyline()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="afdf38806b8b56e43300646a7db58443a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_avoid_1_1_router.html">Router</a> * Avoid::ConnRef::router </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the router scene this connector is in. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the router scene for this connector. </dd></dl>

</div>
</div>
<a class="anchor" id="a19a43ab308285370b304ca2651480ff7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_avoid_1_1_checkpoint.html">Checkpoint</a> &gt; Avoid::ConnRef::routingCheckpoints </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current set of routing checkpoints for this connector. </p>
<dl class="section return"><dt>Returns</dt><dd>The ordered list of Checkpoints that this connector will route via. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b310492a0cf7831694815c79776e7ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_avoid.html#a2dc870f7d17f81f6833e3bb8e77762c2">ConnType</a> Avoid::ConnRef::routingType </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the type of routing performed for this connector. </p>
<dl class="section return"><dt>Returns</dt><dd>The type of routing performed. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d1a26643759adbb84f350285ce42d64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::ConnRef::setCallback </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a callback function that will called to indicate that the connector needs rerouting. </p>
<p>The cb function will be called when shapes are added to, removed from or moved about on the page. The pointer ptr will be passed as an argument to the callback function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>A pointer to the callback function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>A generic pointer that will be passed to the callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b216c9aa42811f1f2786adbda84f02e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::ConnRef::setDestEndpoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a> &amp;&#160;</td>
          <td class="paramname"><em>dstPoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets just a new destination endpoint for this connector. </p>
<p>If the router is using transactions, then this action will occur the next time <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">Router::processTransaction()</a> is called. See <a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">Router::setTransactionUse()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dstPoint</td><td>New destination endpoint for the connector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae66e8c90dc191951fc0f64acc4c06d7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::ConnRef::setEndpoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a> &amp;&#160;</td>
          <td class="paramname"><em>srcPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a> &amp;&#160;</td>
          <td class="paramname"><em>dstPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets both a new source and destination endpoint for this connector. </p>
<p>If the router is using transactions, then this action will occur the next time <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">Router::processTransaction()</a> is called. See <a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">Router::setTransactionUse()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcPoint</td><td>New source endpoint for the connector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstPoint</td><td>New destination endpoint for the connector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7fc22448cc52a1b060f62bcc00d1bb93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::ConnRef::setRoutingCheckpoints </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_avoid_1_1_checkpoint.html">Checkpoint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>checkpoints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the user to specify a set of checkpoints that this connector will route via. </p>
<p>When routing, the connector will attempt to visit each of the points in the checkpoints list in order. It will route from the source point to the first checkpoint, to the second checkpoint, etc. If a checkpoint is unreachable because it lies inside an obstacle, then that checkpoint will be skipped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">checkpoints</td><td>An ordered list of Checkpoints that the connector will attempt to route via. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acfb2eb95a4bfa94fa04081a0bb015583"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::ConnRef::setRoutingType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_avoid.html#a2dc870f7d17f81f6833e3bb8e77762c2">ConnType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the type of routing to be performed for this connector. </p>
<p>If a call to this method changes the current type of routing being used for the connector, then it will get rerouted during the next processTransaction() call, or immediately if transactions are not being used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of routing to be performed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a45ab41f9847a610ba17a326cd05cb266"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::ConnRef::setSourceEndpoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a> &amp;&#160;</td>
          <td class="paramname"><em>srcPoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets just a new source endpoint for this connector. </p>
<p>If the router is using transactions, then this action will occur the next time <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">Router::processTransaction()</a> is called. See <a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">Router::setTransactionUse()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcPoint</td><td>New source endpoint for the connector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a372f58a93c0296814de8d4a3075ad5e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="class_avoid_1_1_junction_ref.html">JunctionRef</a> *, <a class="el" href="class_avoid_1_1_conn_ref.html">ConnRef</a> * &gt; Avoid::ConnRef::splitAtSegment </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>segmentN</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a connector in the centre of the segmentNth segment and creates a junction point there as well as a second connector. </p>
<p>The new junction and connector will be automatically added to the router scene. A slight preference will be given to the connectors connecting to the junction in the same orientation the line segment already existed in.</p>
<dl class="section return"><dt>Returns</dt><dd>A pair containing pointers to the new JunctioRef and <a class="el" href="class_avoid_1_1_conn_ref.html" title="The ConnRef class represents a connector object.">ConnRef</a>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="connector_8h_source.html">connector.h</a></li>
<li>connector.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 21 2013 00:12:58 for libavoid by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3
</small></address>
</body>
</html>
