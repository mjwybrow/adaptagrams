<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Avoid::ConnRef Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<style>
pre { 
    border: dotted 1px #900; 
    padding: 5px; 
    background-color: #ffe;
}
a.anchor:hover {
    text-decoration: none;
}
</style>
</head>
<body>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_avoid.html">Avoid</a></li><li class="navelem"><a class="el" href="class_avoid_1_1_conn_ref.html">ConnRef</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_avoid_1_1_conn_ref-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Avoid::ConnRef Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="class_avoid_1_1_conn_ref.html" title="The ConnRef class represents a connector object. ">ConnRef</a> class represents a connector object.  
 <a href="class_avoid_1_1_conn_ref.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="connector_8h_source.html">connector.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2e08b9bb04ccf383700487932f13c980"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#a2e08b9bb04ccf383700487932f13c980">ConnRef</a> (<a class="el" href="class_avoid_1_1_router.html">Router</a> *<a class="el" href="class_avoid_1_1_conn_ref.html#ace9257a67e94c7899c75af0362e5836f">router</a>, const unsigned int <a class="el" href="class_avoid_1_1_conn_ref.html#a053841a1fdef00b1e90f20f563e1c259">id</a>=0)</td></tr>
<tr class="memdesc:a2e08b9bb04ccf383700487932f13c980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a connector with no endpoints specified.  <a href="#a2e08b9bb04ccf383700487932f13c980">More...</a><br /></td></tr>
<tr class="separator:a2e08b9bb04ccf383700487932f13c980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa469b1767d12e1fa4971004225a0abcd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#aa469b1767d12e1fa4971004225a0abcd">ConnRef</a> (<a class="el" href="class_avoid_1_1_router.html">Router</a> *<a class="el" href="class_avoid_1_1_conn_ref.html#ace9257a67e94c7899c75af0362e5836f">router</a>, const <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a> &amp;src, const <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a> &amp;dst, const unsigned int <a class="el" href="class_avoid_1_1_conn_ref.html#a053841a1fdef00b1e90f20f563e1c259">id</a>=0)</td></tr>
<tr class="memdesc:aa469b1767d12e1fa4971004225a0abcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a connector with endpoints specified.  <a href="#aa469b1767d12e1fa4971004225a0abcd">More...</a><br /></td></tr>
<tr class="separator:aa469b1767d12e1fa4971004225a0abcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12f46fe3ea2f98e687f5a942d0cd51e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#ac12f46fe3ea2f98e687f5a942d0cd51e">~ConnRef</a> ()</td></tr>
<tr class="memdesc:ac12f46fe3ea2f98e687f5a942d0cd51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connector reference destuctor.  <a href="#ac12f46fe3ea2f98e687f5a942d0cd51e">More...</a><br /></td></tr>
<tr class="separator:ac12f46fe3ea2f98e687f5a942d0cd51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66e8c90dc191951fc0f64acc4c06d7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#ae66e8c90dc191951fc0f64acc4c06d7c">setEndpoints</a> (const <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a> &amp;srcPoint, const <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a> &amp;dstPoint)</td></tr>
<tr class="memdesc:ae66e8c90dc191951fc0f64acc4c06d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets both a new source and destination endpoint for this connector.  <a href="#ae66e8c90dc191951fc0f64acc4c06d7c">More...</a><br /></td></tr>
<tr class="separator:ae66e8c90dc191951fc0f64acc4c06d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ab41f9847a610ba17a326cd05cb266"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#a45ab41f9847a610ba17a326cd05cb266">setSourceEndpoint</a> (const <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a> &amp;srcPoint)</td></tr>
<tr class="memdesc:a45ab41f9847a610ba17a326cd05cb266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets just a new source endpoint for this connector.  <a href="#a45ab41f9847a610ba17a326cd05cb266">More...</a><br /></td></tr>
<tr class="separator:a45ab41f9847a610ba17a326cd05cb266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b216c9aa42811f1f2786adbda84f02e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#a7b216c9aa42811f1f2786adbda84f02e">setDestEndpoint</a> (const <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a> &amp;dstPoint)</td></tr>
<tr class="memdesc:a7b216c9aa42811f1f2786adbda84f02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets just a new destination endpoint for this connector.  <a href="#a7b216c9aa42811f1f2786adbda84f02e">More...</a><br /></td></tr>
<tr class="separator:a7b216c9aa42811f1f2786adbda84f02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053841a1fdef00b1e90f20f563e1c259"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#a053841a1fdef00b1e90f20f563e1c259">id</a> (void) const</td></tr>
<tr class="memdesc:a053841a1fdef00b1e90f20f563e1c259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ID of this connector.  <a href="#a053841a1fdef00b1e90f20f563e1c259">More...</a><br /></td></tr>
<tr class="separator:a053841a1fdef00b1e90f20f563e1c259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9257a67e94c7899c75af0362e5836f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_avoid_1_1_router.html">Router</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#ace9257a67e94c7899c75af0362e5836f">router</a> (void) const</td></tr>
<tr class="memdesc:ace9257a67e94c7899c75af0362e5836f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the router scene this connector is in.  <a href="#ace9257a67e94c7899c75af0362e5836f">More...</a><br /></td></tr>
<tr class="separator:ace9257a67e94c7899c75af0362e5836f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf1308dc90317be00acf1fc01c1d276"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#a6bf1308dc90317be00acf1fc01c1d276">needsRepaint</a> (void) const</td></tr>
<tr class="memdesc:a6bf1308dc90317be00acf1fc01c1d276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an indication of whether this connector has a new route and thus needs to be repainted.  <a href="#a6bf1308dc90317be00acf1fc01c1d276">More...</a><br /></td></tr>
<tr class="separator:a6bf1308dc90317be00acf1fc01c1d276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d90245fbe772d30723bd578efa3a45d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_avoid.html#afaa0d7df841c3bace9f3342dab6bc07c">PolyLine</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#a0d90245fbe772d30723bd578efa3a45d">route</a> (void) const</td></tr>
<tr class="memdesc:a0d90245fbe772d30723bd578efa3a45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the current raw "debug" route for the connector.  <a href="#a0d90245fbe772d30723bd578efa3a45d">More...</a><br /></td></tr>
<tr class="separator:a0d90245fbe772d30723bd578efa3a45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7462cd69bd1d2c4dd318119558b4a94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_avoid.html#afaa0d7df841c3bace9f3342dab6bc07c">PolyLine</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#ab7462cd69bd1d2c4dd318119558b4a94">displayRoute</a> (void)</td></tr>
<tr class="memdesc:ab7462cd69bd1d2c4dd318119558b4a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the current display version of the route for the connector.  <a href="#ab7462cd69bd1d2c4dd318119558b4a94">More...</a><br /></td></tr>
<tr class="separator:ab7462cd69bd1d2c4dd318119558b4a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1a26643759adbb84f350285ce42d64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#a9d1a26643759adbb84f350285ce42d64">setCallback</a> (void(*cb)(void *), void *ptr)</td></tr>
<tr class="memdesc:a9d1a26643759adbb84f350285ce42d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a callback function that will called to indicate that the connector needs rerouting.  <a href="#a9d1a26643759adbb84f350285ce42d64">More...</a><br /></td></tr>
<tr class="separator:a9d1a26643759adbb84f350285ce42d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2689d4fde1f3489976324abb04bcab72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_avoid.html#a2dc870f7d17f81f6833e3bb8e77762c2">ConnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#a2689d4fde1f3489976324abb04bcab72">routingType</a> (void) const</td></tr>
<tr class="memdesc:a2689d4fde1f3489976324abb04bcab72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of routing performed for this connector.  <a href="#a2689d4fde1f3489976324abb04bcab72">More...</a><br /></td></tr>
<tr class="separator:a2689d4fde1f3489976324abb04bcab72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb2eb95a4bfa94fa04081a0bb015583"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#acfb2eb95a4bfa94fa04081a0bb015583">setRoutingType</a> (<a class="el" href="namespace_avoid.html#a2dc870f7d17f81f6833e3bb8e77762c2">ConnType</a> type)</td></tr>
<tr class="memdesc:acfb2eb95a4bfa94fa04081a0bb015583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the type of routing to be performed for this connector.  <a href="#acfb2eb95a4bfa94fa04081a0bb015583">More...</a><br /></td></tr>
<tr class="separator:acfb2eb95a4bfa94fa04081a0bb015583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372f58a93c0296814de8d4a3075ad5e4"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="class_avoid_1_1_junction_ref.html">JunctionRef</a> *, <a class="el" href="class_avoid_1_1_conn_ref.html">ConnRef</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#a372f58a93c0296814de8d4a3075ad5e4">splitAtSegment</a> (const size_t segmentN)</td></tr>
<tr class="memdesc:a372f58a93c0296814de8d4a3075ad5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a connector in the centre of the segmentNth segment and creates a junction point there as well as a second connector.  <a href="#a372f58a93c0296814de8d4a3075ad5e4">More...</a><br /></td></tr>
<tr class="separator:a372f58a93c0296814de8d4a3075ad5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc22448cc52a1b060f62bcc00d1bb93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#a7fc22448cc52a1b060f62bcc00d1bb93">setRoutingCheckpoints</a> (const std::vector&lt; <a class="el" href="class_avoid_1_1_checkpoint.html">Checkpoint</a> &gt; &amp;checkpoints)</td></tr>
<tr class="memdesc:a7fc22448cc52a1b060f62bcc00d1bb93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the user to specify a set of checkpoints that this connector will route via.  <a href="#a7fc22448cc52a1b060f62bcc00d1bb93">More...</a><br /></td></tr>
<tr class="separator:a7fc22448cc52a1b060f62bcc00d1bb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38586487d88c4b98a7c5c1a2df6d1c95"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_avoid_1_1_checkpoint.html">Checkpoint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#a38586487d88c4b98a7c5c1a2df6d1c95">routingCheckpoints</a> (void) const</td></tr>
<tr class="memdesc:a38586487d88c4b98a7c5c1a2df6d1c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current set of routing checkpoints for this connector.  <a href="#a38586487d88c4b98a7c5c1a2df6d1c95">More...</a><br /></td></tr>
<tr class="separator:a38586487d88c4b98a7c5c1a2df6d1c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7f970e8bee1ccf69a0d5521ca1f177"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a>, <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#abb7f970e8bee1ccf69a0d5521ca1f177">endpointConnEnds</a> (void) const</td></tr>
<tr class="memdesc:abb7f970e8bee1ccf69a0d5521ca1f177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns ConnEnds specifying what this connector is attached to.  <a href="#abb7f970e8bee1ccf69a0d5521ca1f177">More...</a><br /></td></tr>
<tr class="separator:abb7f970e8bee1ccf69a0d5521ca1f177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392eeffe4cdd76267b0d1bb654562382"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#a392eeffe4cdd76267b0d1bb654562382">setFixedRoute</a> (const <a class="el" href="namespace_avoid.html#afaa0d7df841c3bace9f3342dab6bc07c">PolyLine</a> &amp;<a class="el" href="class_avoid_1_1_conn_ref.html#a0d90245fbe772d30723bd578efa3a45d">route</a>)</td></tr>
<tr class="memdesc:a392eeffe4cdd76267b0d1bb654562382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a fixed user-specified route for this connector.  <a href="#a392eeffe4cdd76267b0d1bb654562382">More...</a><br /></td></tr>
<tr class="separator:a392eeffe4cdd76267b0d1bb654562382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bea9ff902f7b2faf8be50f8aa82f90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#ab3bea9ff902f7b2faf8be50f8aa82f90">setFixedExistingRoute</a> (void)</td></tr>
<tr class="memdesc:ab3bea9ff902f7b2faf8be50f8aa82f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a fixed existing route for this connector.  <a href="#ab3bea9ff902f7b2faf8be50f8aa82f90">More...</a><br /></td></tr>
<tr class="separator:ab3bea9ff902f7b2faf8be50f8aa82f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6c783ffb50b315769f1a0c29597136"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#a5e6c783ffb50b315769f1a0c29597136">hasFixedRoute</a> (void) const</td></tr>
<tr class="memdesc:a5e6c783ffb50b315769f1a0c29597136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the connector route is marked as fixed.  <a href="#a5e6c783ffb50b315769f1a0c29597136">More...</a><br /></td></tr>
<tr class="separator:a5e6c783ffb50b315769f1a0c29597136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b8b54df72eb1da45e8a854a3276e4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_conn_ref.html#a95b8b54df72eb1da45e8a854a3276e4a">clearFixedRoute</a> (void)</td></tr>
<tr class="memdesc:a95b8b54df72eb1da45e8a854a3276e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the connector to being automatically routed if it was marked as fixed.  <a href="#a95b8b54df72eb1da45e8a854a3276e4a">More...</a><br /></td></tr>
<tr class="separator:a95b8b54df72eb1da45e8a854a3276e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="class_avoid_1_1_conn_ref.html" title="The ConnRef class represents a connector object. ">ConnRef</a> class represents a connector object. </p>
<p>Connectors are a (possible multi-segment) line between two points. They are routed intelligently so as not to overlap any of the shape objects in the <a class="el" href="class_avoid_1_1_router.html" title="The Router class represents a libavoid router instance. ">Router</a> scene.</p>
<p>Routing penalties can be applied, resulting in more aesthetically pleasing connector paths with fewer segments or less severe bend-points.</p>
<p>You can set a function to be called when the connector has been rerouted and needs to be redrawn. Alternatively, you can query the connector's <a class="el" href="class_avoid_1_1_conn_ref.html#a6bf1308dc90317be00acf1fc01c1d276" title="Returns an indication of whether this connector has a new route and thus needs to be repainted...">needsRepaint()</a> function to determine this manually.</p>
<p>Usually, it is expected that you would create a <a class="el" href="class_avoid_1_1_conn_ref.html" title="The ConnRef class represents a connector object. ">ConnRef</a> for each connector in your diagram and keep that reference in your own connector class. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2e08b9bb04ccf383700487932f13c980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e08b9bb04ccf383700487932f13c980">&#9670;&nbsp;</a></span>ConnRef() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Avoid::ConnRef::ConnRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_avoid_1_1_router.html">Router</a> *&#160;</td>
          <td class="paramname"><em>router</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>id</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a connector with no endpoints specified. </p>
<p>The constructor requires a valid <a class="el" href="class_avoid_1_1_router.html" title="The Router class represents a libavoid router instance. ">Router</a> instance. This router will take ownership of the connector. Hence, you should not call the destructor yourself, but should instead call <a class="el" href="class_avoid_1_1_router.html#a316f15b3e974c273bb55cfb19b751394" title="Remove a connector from the router scene. ">Router::deleteConnector()</a> and the router instance will remove and then free the connector's memory.</p>
<dl class="section note"><dt>Note</dt><dd>Regarding IDs: You can let libavoid manually handle IDs by not specifying them. Alternatively, you can specify all IDs yourself, but you must be careful to makes sure that each object in the scene (shape, connector, cluster, etc) is given a unique, positive ID. This uniqueness is checked if assertions are enabled, but if not and there are clashes then strange things can happen.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">router</td><td>The router scene to place the connector into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Optionally, a positive integer ID unique among all objects. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa469b1767d12e1fa4971004225a0abcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa469b1767d12e1fa4971004225a0abcd">&#9670;&nbsp;</a></span>ConnRef() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Avoid::ConnRef::ConnRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_avoid_1_1_router.html">Router</a> *&#160;</td>
          <td class="paramname"><em>router</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>id</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a connector with endpoints specified. </p>
<p>The constructor requires a valid <a class="el" href="class_avoid_1_1_router.html" title="The Router class represents a libavoid router instance. ">Router</a> instance. This router will take ownership of the connector. Hence, you should not call the destructor yourself, but should instead call <a class="el" href="class_avoid_1_1_router.html#a316f15b3e974c273bb55cfb19b751394" title="Remove a connector from the router scene. ">Router::deleteConnector()</a> and the router instance will remove and then free the connector's memory.</p>
<p>If an ID is not specified, then one will be assigned to the shape. If assigning an ID yourself, note that it should be a unique positive integer. Also, IDs are given to all objects in a scene, so the same ID cannot be given to a shape and a connector for example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">router</td><td>The router scene to place the connector into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>A unique positive integer ID for the connector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The source endpoint of the connector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>The destination endpoint of the connector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac12f46fe3ea2f98e687f5a942d0cd51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac12f46fe3ea2f98e687f5a942d0cd51e">&#9670;&nbsp;</a></span>~ConnRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Avoid::ConnRef::~ConnRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connector reference destuctor. </p>
<p>Do not call this yourself, instead call <a class="el" href="class_avoid_1_1_router.html#a316f15b3e974c273bb55cfb19b751394" title="Remove a connector from the router scene. ">Router::deleteConnector()</a>. Ownership of this object belongs to the router scene. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a95b8b54df72eb1da45e8a854a3276e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95b8b54df72eb1da45e8a854a3276e4a">&#9670;&nbsp;</a></span>clearFixedRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::ConnRef::clearFixedRoute </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the connector to being automatically routed if it was marked as fixed. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_avoid_1_1_conn_ref.html#a392eeffe4cdd76267b0d1bb654562382" title="Sets a fixed user-specified route for this connector. ">setFixedRoute()</a> </dd></dl>

</div>
</div>
<a id="ab7462cd69bd1d2c4dd318119558b4a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7462cd69bd1d2c4dd318119558b4a94">&#9670;&nbsp;</a></span>displayRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_avoid_1_1_polygon.html">Polygon</a> &amp; Avoid::ConnRef::displayRoute </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the current display version of the route for the connector. </p>
<p>The display version of a route has been simplified to collapse all collinear line segments into single segments. It also has all post-processing applied to the route, including centering, curved corners and nudging apart of overlapping segments.</p>
<dl class="section return"><dt>Returns</dt><dd>The PolyLine display route for the connector. </dd></dl>

</div>
</div>
<a id="abb7f970e8bee1ccf69a0d5521ca1f177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7f970e8bee1ccf69a0d5521ca1f177">&#9670;&nbsp;</a></span>endpointConnEnds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a>, <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a> &gt; Avoid::ConnRef::endpointConnEnds </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns ConnEnds specifying what this connector is attached to. </p>
<p>This may be useful during hyperedge rerouting. You can check the type and properties of the <a class="el" href="class_avoid_1_1_conn_end.html" title="The ConnEnd class represents different possible endpoints for connectors. ">ConnEnd</a> objects to find out what this connector is attached to. The <a class="el" href="class_avoid_1_1_conn_end.html#a9d82874f62afeba20ecaf017d82402a5" title="Returns the kind of connection this ConnEnd represents. ">ConnEnd::type()</a> will be ConnEndEmpty if the connector has not had its endpoints initialised.</p>
<dl class="section note"><dt>Note</dt><dd>If the router is using transactions, you might get unexpected results if you call this after changing objects but before calling <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently. ">Router::processTransaction()</a>. In this case changes to ConnEnds for the connector may be queued and not yet applied, so you will get old (or empty) values.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of <a class="el" href="class_avoid_1_1_conn_end.html" title="The ConnEnd class represents different possible endpoints for connectors. ">ConnEnd</a> objects specifying what the connector is attached to. </dd></dl>

</div>
</div>
<a id="a5e6c783ffb50b315769f1a0c29597136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e6c783ffb50b315769f1a0c29597136">&#9670;&nbsp;</a></span>hasFixedRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Avoid::ConnRef::hasFixedRoute </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the connector route is marked as fixed. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the connector route is fixed, false otherwise. </dd></dl>

</div>
</div>
<a id="a053841a1fdef00b1e90f20f563e1c259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a053841a1fdef00b1e90f20f563e1c259">&#9670;&nbsp;</a></span>id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Avoid::ConnRef::id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ID of this connector. </p>
<dl class="section return"><dt>Returns</dt><dd>The ID of the connector. </dd></dl>

</div>
</div>
<a id="a6bf1308dc90317be00acf1fc01c1d276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf1308dc90317be00acf1fc01c1d276">&#9670;&nbsp;</a></span>needsRepaint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Avoid::ConnRef::needsRepaint </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an indication of whether this connector has a new route and thus needs to be repainted. </p>
<p>If the connector has been rerouted and need repainting, the <a class="el" href="class_avoid_1_1_conn_ref.html#ab7462cd69bd1d2c4dd318119558b4a94" title="Returns a reference to the current display version of the route for the connector. ">displayRoute()</a> method can be called to get a reference to the new route.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the connector requires repainting, or false if it does not. </dd></dl>

</div>
</div>
<a id="a0d90245fbe772d30723bd578efa3a45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d90245fbe772d30723bd578efa3a45d">&#9670;&nbsp;</a></span>route()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_avoid.html#afaa0d7df841c3bace9f3342dab6bc07c">PolyLine</a> &amp; Avoid::ConnRef::route </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the current raw "debug" route for the connector. </p>
<p>This is a raw "debug" shortest path version of the route, where each line segment in the route may be made up of multiple collinear line segments. It also has no post-processing (i.e., centering, nudging apart of overlapping paths, or curving of corners) applied to it. A route to display to the user can be obtained by calling <a class="el" href="class_avoid_1_1_conn_ref.html#ab7462cd69bd1d2c4dd318119558b4a94" title="Returns a reference to the current display version of the route for the connector. ">displayRoute()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The PolyLine route for the connector. </dd></dl>

</div>
</div>
<a id="ace9257a67e94c7899c75af0362e5836f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9257a67e94c7899c75af0362e5836f">&#9670;&nbsp;</a></span>router()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_avoid_1_1_router.html">Router</a> * Avoid::ConnRef::router </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the router scene this connector is in. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the router scene for this connector. </dd></dl>

</div>
</div>
<a id="a38586487d88c4b98a7c5c1a2df6d1c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38586487d88c4b98a7c5c1a2df6d1c95">&#9670;&nbsp;</a></span>routingCheckpoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_avoid_1_1_checkpoint.html">Checkpoint</a> &gt; Avoid::ConnRef::routingCheckpoints </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current set of routing checkpoints for this connector. </p>
<dl class="section return"><dt>Returns</dt><dd>The ordered list of Checkpoints that this connector will route via. </dd></dl>

</div>
</div>
<a id="a2689d4fde1f3489976324abb04bcab72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2689d4fde1f3489976324abb04bcab72">&#9670;&nbsp;</a></span>routingType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_avoid.html#a2dc870f7d17f81f6833e3bb8e77762c2">ConnType</a> Avoid::ConnRef::routingType </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the type of routing performed for this connector. </p>
<dl class="section return"><dt>Returns</dt><dd>The type of routing performed. </dd></dl>

</div>
</div>
<a id="a9d1a26643759adbb84f350285ce42d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d1a26643759adbb84f350285ce42d64">&#9670;&nbsp;</a></span>setCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::ConnRef::setCallback </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a callback function that will called to indicate that the connector needs rerouting. </p>
<p>The cb function will be called when shapes are added to, removed from or moved about on the page. The pointer ptr will be passed as an argument to the callback function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>A pointer to the callback function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>A generic pointer that will be passed to the callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b216c9aa42811f1f2786adbda84f02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b216c9aa42811f1f2786adbda84f02e">&#9670;&nbsp;</a></span>setDestEndpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::ConnRef::setDestEndpoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a> &amp;&#160;</td>
          <td class="paramname"><em>dstPoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets just a new destination endpoint for this connector. </p>
<p>If the router is using transactions, then this action will occur the next time <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently. ">Router::processTransaction()</a> is called. See <a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">Router::setTransactionUse()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dstPoint</td><td>New destination endpoint for the connector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae66e8c90dc191951fc0f64acc4c06d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66e8c90dc191951fc0f64acc4c06d7c">&#9670;&nbsp;</a></span>setEndpoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::ConnRef::setEndpoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a> &amp;&#160;</td>
          <td class="paramname"><em>srcPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a> &amp;&#160;</td>
          <td class="paramname"><em>dstPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets both a new source and destination endpoint for this connector. </p>
<p>If the router is using transactions, then this action will occur the next time <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently. ">Router::processTransaction()</a> is called. See <a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">Router::setTransactionUse()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcPoint</td><td>New source endpoint for the connector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstPoint</td><td>New destination endpoint for the connector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3bea9ff902f7b2faf8be50f8aa82f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3bea9ff902f7b2faf8be50f8aa82f90">&#9670;&nbsp;</a></span>setFixedExistingRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::ConnRef::setFixedExistingRoute </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a fixed existing route for this connector. </p>
<p>libavoid will no longer calculate object-avoiding paths for this connector but instead just return the current exisitng route. The path of this connector will still be considered for the purpose of nudging and routing other non-fixed connectors.</p>
<dl class="section note"><dt>Note</dt><dd>The endpoints of this connector will remain at their current positions, even while remaining 'attached' to shapes or junctions that move.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_avoid_1_1_conn_ref.html#a392eeffe4cdd76267b0d1bb654562382" title="Sets a fixed user-specified route for this connector. ">setFixedRoute()</a> </dd>
<dd>
<a class="el" href="class_avoid_1_1_conn_ref.html#a95b8b54df72eb1da45e8a854a3276e4a" title="Returns the connector to being automatically routed if it was marked as fixed. ">clearFixedRoute()</a> </dd></dl>

</div>
</div>
<a id="a392eeffe4cdd76267b0d1bb654562382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a392eeffe4cdd76267b0d1bb654562382">&#9670;&nbsp;</a></span>setFixedRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::ConnRef::setFixedRoute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_avoid.html#afaa0d7df841c3bace9f3342dab6bc07c">PolyLine</a> &amp;&#160;</td>
          <td class="paramname"><em>route</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a fixed user-specified route for this connector. </p>
<p>libavoid will no longer calculate object-avoiding paths for this connector but instead just return the specified route. The path of this connector will still be considered for the purpose of nudging and routing other non-fixed connectors.</p>
<dl class="section note"><dt>Note</dt><dd>This will reset the endpoints of the connector to the two ends of the given route, which may cause it to become dettached from any shapes or junctions. You can alternatively call <a class="el" href="class_avoid_1_1_conn_ref.html#ab3bea9ff902f7b2faf8be50f8aa82f90" title="Sets a fixed existing route for this connector. ">setFixedExistingRoute()</a> for connectors with valid routes in hyperedges that you would like to remain attached.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">route</td><td>The new fixed route for the connector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_avoid_1_1_conn_ref.html#ab3bea9ff902f7b2faf8be50f8aa82f90" title="Sets a fixed existing route for this connector. ">setFixedExistingRoute()</a> </dd>
<dd>
<a class="el" href="class_avoid_1_1_conn_ref.html#a95b8b54df72eb1da45e8a854a3276e4a" title="Returns the connector to being automatically routed if it was marked as fixed. ">clearFixedRoute()</a> </dd></dl>

</div>
</div>
<a id="a7fc22448cc52a1b060f62bcc00d1bb93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc22448cc52a1b060f62bcc00d1bb93">&#9670;&nbsp;</a></span>setRoutingCheckpoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::ConnRef::setRoutingCheckpoints </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_avoid_1_1_checkpoint.html">Checkpoint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>checkpoints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the user to specify a set of checkpoints that this connector will route via. </p>
<p>When routing, the connector will attempt to visit each of the points in the checkpoints list in order. It will route from the source point to the first checkpoint, to the second checkpoint, etc. If a checkpoint is unreachable because it lies inside an obstacle, then that checkpoint will be skipped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">checkpoints</td><td>An ordered list of Checkpoints that the connector will attempt to route via. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfb2eb95a4bfa94fa04081a0bb015583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb2eb95a4bfa94fa04081a0bb015583">&#9670;&nbsp;</a></span>setRoutingType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::ConnRef::setRoutingType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_avoid.html#a2dc870f7d17f81f6833e3bb8e77762c2">ConnType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the type of routing to be performed for this connector. </p>
<p>If a call to this method changes the current type of routing being used for the connector, then it will get rerouted during the next processTransaction() call, or immediately if transactions are not being used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of routing to be performed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45ab41f9847a610ba17a326cd05cb266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ab41f9847a610ba17a326cd05cb266">&#9670;&nbsp;</a></span>setSourceEndpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::ConnRef::setSourceEndpoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_avoid_1_1_conn_end.html">ConnEnd</a> &amp;&#160;</td>
          <td class="paramname"><em>srcPoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets just a new source endpoint for this connector. </p>
<p>If the router is using transactions, then this action will occur the next time <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently. ">Router::processTransaction()</a> is called. See <a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">Router::setTransactionUse()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcPoint</td><td>New source endpoint for the connector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a372f58a93c0296814de8d4a3075ad5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a372f58a93c0296814de8d4a3075ad5e4">&#9670;&nbsp;</a></span>splitAtSegment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="class_avoid_1_1_junction_ref.html">JunctionRef</a> *, <a class="el" href="class_avoid_1_1_conn_ref.html">ConnRef</a> * &gt; Avoid::ConnRef::splitAtSegment </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>segmentN</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a connector in the centre of the segmentNth segment and creates a junction point there as well as a second connector. </p>
<p>The new junction and connector will be automatically added to the router scene. A slight preference will be given to the connectors connecting to the junction in the same orientation the line segment already existed in.</p>
<dl class="section return"><dt>Returns</dt><dd>A pair containing pointers to the new <a class="el" href="class_avoid_1_1_junction_ref.html" title="The JunctionRef class represents a fixed or free-floating point that connectors can be attached to...">JunctionRef</a> and <a class="el" href="class_avoid_1_1_conn_ref.html" title="The ConnRef class represents a connector object. ">ConnRef</a>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="connector_8h_source.html">connector.h</a></li>
<li>connector.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 7 2018 09:51:35 for libavoid by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
